<html>
<head>
	<title>Hexapod</title>
		<style>
			line {
				stroke-width: 2px;
				stroke: black;
				stroke-linecap: round;
			}
			#hexapod_body {
				fill: green;
				stroke: black;
				stroke-width: 0.5px;
			}

			#hexapod_leg_LF_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LF_F { stroke: rgba(128,0,255,1); }
			#hexapod_leg_LF_T { stroke: rgba(255,0,0,1); }

			#hexapod_leg_LM_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LM_F { stroke: rgba(128,0,255,1); }
			#hexapod_leg_LM_T { stroke: rgba(255,0,0,1); }
			
			#hexapod_leg_LB_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LB_F { stroke: rgba(128,0,255,0.7); }
			#hexapod_leg_LB_T { stroke: rgba(255,0,0,1); }
			

			#hexapod_leg_RF_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RF_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RF_T { stroke: rgba(0,255,0,1); }

			#hexapod_leg_RM_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RM_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RM_T { stroke: rgba(0,255,0,1); }
			
			#hexapod_leg_RB_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RB_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RB_T { stroke: rgba(0,255,0,1); }
			
			.svg_text_dbg {
				font: 2.5px sans-serif;
				fill: rgba(0,0,0,1);
				stroke: rgba(255,255,255,1);
				stroke-width: 0.1px;
			}
	</style>
</head>
<body>
<svg width="600" height="600" id="svgimg">
	<g id="hexapod" transform="translate(300,300) scale(4)">
		<polygon points="0,0 1,1 2,2 3,3 4,4 5,5" id="hexapod_body" />
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_C" /><text x="0" y="0" id="hexapod_leg_LF_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_F" /><text x="0" y="0" id="hexapod_leg_LF_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_T" /><text x="0" y="0" id="hexapod_leg_LF_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_C" /><text x="0" y="0" id="hexapod_leg_LM_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_F" /><text x="0" y="0" id="hexapod_leg_LM_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_T" /><text x="0" y="0" id="hexapod_leg_LM_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_C" /><text x="0" y="0" id="hexapod_leg_LB_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_F" /><text x="0" y="0" id="hexapod_leg_LB_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_T" /><text x="0" y="0" id="hexapod_leg_LB_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_C" /><text x="0" y="0" id="hexapod_leg_RF_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_F" /><text x="0" y="0" id="hexapod_leg_RF_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_T" /><text x="0" y="0" id="hexapod_leg_RF_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_C" /><text x="0" y="0" id="hexapod_leg_RM_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_F" /><text x="0" y="0" id="hexapod_leg_RM_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_T" /><text x="0" y="0" id="hexapod_leg_RM_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_C" /><text x="0" y="0" id="hexapod_leg_RB_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_F" /><text x="0" y="0" id="hexapod_leg_RB_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_T" /><text x="0" y="0" id="hexapod_leg_RB_T_DBG" class="svg_text_dbg"></text>
	</g>
</svg>
<script>
	function G(id) {
		return document.getElementById(id);
	}
	var hexapod_image_objects = {
		svgimg: G('svgimg'),
		body_legs: ["LF", "RF", "RM", "RB", "LB", "LM"],
		body: G('hexapod_body'),
		leg: {
			LF: {
				C: G('hexapod_leg_LF_C'),
				F: G('hexapod_leg_LF_F'),
				T: G('hexapod_leg_LF_T'),
			},
			LM: {
				C: G('hexapod_leg_LM_C'),
				F: G('hexapod_leg_LM_F'),
				T: G('hexapod_leg_LM_T'),
			},
			LB: {
				C: G('hexapod_leg_LB_C'),
				F: G('hexapod_leg_LB_F'),
				T: G('hexapod_leg_LB_T'),
			},
			RF: {
				C: G('hexapod_leg_RF_C'),
				F: G('hexapod_leg_RF_F'),
				T: G('hexapod_leg_RF_T'),
			},
			RM: {
				C: G('hexapod_leg_RM_C'),
				F: G('hexapod_leg_RM_F'),
				T: G('hexapod_leg_RM_T'),
			},
			RB: {
				C: G('hexapod_leg_RB_C'),
				F: G('hexapod_leg_RB_F'),
				T: G('hexapod_leg_RB_T'),
			},
		},
		dbg: {
			leg: {
				LF: {
					C: G('hexapod_leg_LF_C_DBG'),
					F: G('hexapod_leg_LF_F_DBG'),
					T: G('hexapod_leg_LF_T_DBG'),
				},
				LM: {
					C: G('hexapod_leg_LM_C_DBG'),
					F: G('hexapod_leg_LM_F_DBG'),
					T: G('hexapod_leg_LM_T_DBG'),
				},
				LB: {
					C: G('hexapod_leg_LB_C_DBG'),
					F: G('hexapod_leg_LB_F_DBG'),
					T: G('hexapod_leg_LB_T_DBG'),
				},
				RF: {
					C: G('hexapod_leg_RF_C_DBG'),
					F: G('hexapod_leg_RF_F_DBG'),
					T: G('hexapod_leg_RF_T_DBG'),
				},
				RM: {
					C: G('hexapod_leg_RM_C_DBG'),
					F: G('hexapod_leg_RM_F_DBG'),
					T: G('hexapod_leg_RM_T_DBG'),
				},
				RB: {
					C: G('hexapod_leg_RB_C_DBG'),
					F: G('hexapod_leg_RB_F_DBG'),
					T: G('hexapod_leg_RB_T_DBG'),
				},
			}
		}
	};
	// hexapod sizes
	var hexapod = {};
	hexapod.legs = ["LF", "LM", "LB", "RF", "RM", "RB"];
	hexapod.config = {
			body: {
				x: 0, y: 0, z: 3,	// z - distance from ground
				AngX: 0, AngY: 0, AngZ: 0,
				LF:  { x:  15, y:  15, z: 0 },
				LM:  { x:   0, y:  15, z: 0 },
				LB:  { x: -15, y:  15, z: 0 },
				RF:  { x:  15, y: -15, z: 0 },
				RM:  { x:   0, y: -15, z: 0 },
				RB:  { x: -15, y: -15, z: 0 }
			},
			leg: {
				LF: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } },	// TODO min and max!!! AngF (0...90)
				LM: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } },
				LB: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } },
				RF: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } },
				RM: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } },
				RB: { AngC: { min: -50, max: 50, default: 0 }, Lc: 2, Lf: 4, Lt: 8, L: { min: 4, max: 12, default: 12 } }
			},
			gait: {
				type: "RIPPLE",	// balance between stable (4 legs on the ground) and speed (not so slow as wave 1 by 1, bu not so fast as with tripod)
				sequence: [
					{ "LF": 0, "LM": 0, "LB": 1, "RF": 0, "RM": 1, "RB": 0 },	// 0 - on the ground (stance), 1 - in the air (swing)
					{ "LF": 0, "LM": 0, "LB": 1, "RF": 1, "RM": 0, "RB": 0 },
					{ "LF": 0, "LM": 1, "LB": 0, "RF": 1, "RM": 0, "RB": 0 },
					{ "LF": 0, "LM": 1, "LB": 0, "RF": 0, "RM": 0, "RB": 1 },
					{ "LF": 1, "LM": 0, "LB": 0, "RF": 0, "RM": 0, "RB": 1 },
					{ "LF": 1, "LM": 0, "LB": 0, "RF": 0, "RM": 1, "RB": 0 },
					{ "LF": 0, "LM": 0, "LB": 1, "RF": 0, "RM": 1, "RB": 0 },
					{ "LF": 0, "LM": 0, "LB": 1, "RF": 1, "RM": 0, "RB": 0 },
					{ "LF": 0, "LM": 1, "LB": 0, "RF": 1, "RM": 0, "RB": 0 },
					{ "LF": 0, "LM": 1, "LB": 0, "RF": 0, "RM": 0, "RB": 1 },
					{ "LF": 1, "LM": 0, "LB": 0, "RF": 0, "RM": 0, "RB": 1 },
					{ "LF": 1, "LM": 0, "LB": 0, "RF": 0, "RM": 1, "RB": 0 }
				]
			}
		};
	hexapod.const = {
		leg: {
			LF: { Lf2: false, Lt2: false, LtLf: false },
			LM: { Lf2: false, Lt2: false, LtLf: false },
			LB: { Lf2: false, Lt2: false, LtLf: false },
			RF: { Lf2: false, Lt2: false, LtLf: false },
			RM: { Lf2: false, Lt2: false, LtLf: false },
			RB: { Lf2: false, Lt2: false, LtLf: false }
		}
	},
	hexapod.preState = false;
	hexapod.state = {
			body: {
				x0: 0, y0: 0, z0:0,	// inititial position, TODO update after gait*steps finished
				x: 0, y: 0, z: 0, 
				AngX: 0, AngY: 0, AngZ: 0,
				LF:  { x: false, y: false, z: false },
				LM:  { x: false, y: false, z: false },
				LB:  { x: false, y: false, z: false },
				RF:  { x: false, y: false, z: false },
				RM:  { x: false, y: false, z: false },
				RB:  { x: false, y: false, z: false },
			},
			leg: {
				LF: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				LM: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				LB: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RF: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RM: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RB: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false }
			}
		};
	function legAng (ID) {
		// TODO, precheck leg mimits:
		// 1. create 3D polygon of max/min available positions, including angles limits
		// 2. check if x1,y1,z1 in that polygon
		hexapod.state.leg[ID].L = Math.sqrt(Math.pow(hexapod.state.leg[ID].x - hexapod.state.body[ID].x, 2) + Math.pow(hexapod.state.leg[ID].y - hexapod.state.body[ID].y, 2));

		/*
		                      
		AngleCoxa = atan2 ( (y1-y0), (x1-x0) )
								
		*/
		hexapod.state.leg[ID].AngC = _rad2deg(Math.atan2((hexapod.state.leg[ID].y - hexapod.state.body[ID].y), (hexapod.state.leg[ID].x - hexapod.state.body[ID].x)) - hexapod.const.leg[ID].AngCRad);	// -90...90
		if (hexapod.state.leg[ID].AngC > 180) hexapod.state.leg[ID].AngC -= 360;
		/*
								   Lf^2 + (D^2 + (L - Lc)^2) - Lt^2       PI             L - Lc
			AngleFemur = arccos ( ---------------------------------- ) - ---- + arctan( -------- )
								   2 * Lf * sqrt(D^2 + (L - Lc)^2)         2               D
		*/
		var tmp = Math.pow(hexapod.state.body.z, 2) + Math.pow( hexapod.state.leg[ID].L - hexapod.config.leg[ID].Lc, 2);
		hexapod.state.leg[ID].AngF = _rad2deg(Math.acos( (hexapod.const.leg[ID].Lf2 + tmp - hexapod.const.leg[ID].Lt2) / (2 * hexapod.config.leg[ID].Lf * Math.sqrt(tmp) ) ) - Math.PI/2 + Math.atan((hexapod.state.leg[ID].L - hexapod.config.leg[ID].Lc) / hexapod.state.body.z));

		/*
							   Lt^2 + Lf^2 - (D^2 + (L - Lc)^2)
		AngleTibia = arccos ( --------------------------------- )
										 2 * Lt * Lf
		*/
		hexapod.state.leg[ID].AngT = _rad2deg(Math.acos((hexapod.const.leg[ID].Lt2 + hexapod.const.leg[ID].Lf2 - tmp) / (2 * hexapod.const.leg[ID].LtLf)));
	}
	
	function _degNorm(deg) {
		while (deg > 360 || deg < 0) {
			if (deg < 0) deg += 360;
			if (deg > 360) deg -= 360;
		}
		return deg;
	}
	function _deg2rad(deg) {
		return Math.PI/180*deg;
	}

	function _rad2deg(rad) {
		return _degNorm(180/Math.PI*rad);
	}
	
	function initBody() {
		hexapod.state.body.x    = parseFloat(hexapod.config.body.x);
		hexapod.state.body.y    = parseFloat(hexapod.config.body.y);
		hexapod.state.body.z    = parseFloat(hexapod.config.body.z);
		hexapod.state.body.x0   = parseFloat(hexapod.config.body.x);
		hexapod.state.body.y0   = parseFloat(hexapod.config.body.y);
		hexapod.state.body.z0   = parseFloat(hexapod.config.body.z);
		hexapod.state.body.AngX = parseFloat(hexapod.config.body.AngX);
		hexapod.state.body.AngY = parseFloat(hexapod.config.body.AngY);
		hexapod.state.body.AngZ = parseFloat(hexapod.config.body.AngZ);
	}
	
	function initLeg(ID) {
		// init leg XYZ based on init AngC and default length od leg
		hexapod.state.leg[ID].z = -hexapod.state.body.z;	// init leg D from ground;
		var tmp = _rad2deg(Math.atan2((hexapod.config.body[ID].y - hexapod.config.body.y), (hexapod.config.body[ID].x - hexapod.config.body.x)));
		hexapod.state.leg[ID].x = Math.cos(_deg2rad(hexapod.config.leg[ID].AngC.default+tmp)) * hexapod.config.leg[ID].L.default + hexapod.config.body[ID].x;
		hexapod.state.leg[ID].y = Math.sin(_deg2rad(hexapod.config.leg[ID].AngC.default+tmp)) * hexapod.config.leg[ID].L.default + hexapod.config.body[ID].y;
	}
	
	function initState() {
		initBody();
		for (var i = 0; i < hexapod.legs.length; i++) {
			initLeg(hexapod.legs[i]);
		}
	}
	
	function initConst() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			//console.log("initConst", hexapod.legs[i]);
			hexapod.const.leg[hexapod.legs[i]].Lf2 = Math.pow(hexapod.config.leg[hexapod.legs[i]].Lf, 2);
			hexapod.const.leg[hexapod.legs[i]].Lt2 = Math.pow(hexapod.config.leg[hexapod.legs[i]].Lt, 2);
			hexapod.const.leg[hexapod.legs[i]].LtLf = hexapod.config.leg[hexapod.legs[i]].Lt * hexapod.config.leg[hexapod.legs[i]].Lf;
			hexapod.const.leg[hexapod.legs[i]].AngCRad = Math.atan2((hexapod.config.body[hexapod.legs[i]].y - hexapod.config.body.y), (hexapod.config.body[hexapod.legs[i]].x - hexapod.config.body.x));
		}
		// TODO init min/max 3d polygon for legs
	}
	
	function initHexa() {
		initConst();
		initState();
		update();
		updateImage();
	}
	
	function updateBody() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			hexapod.state.body[hexapod.legs[i]].x = hexapod.state.body.x + hexapod.config.body[hexapod.legs[i]].x*Math.cos(_deg2rad(hexapod.state.body.AngZ)) - hexapod.config.body[hexapod.legs[i]].y*Math.sin(_deg2rad(hexapod.state.body.AngZ));
			hexapod.state.body[hexapod.legs[i]].y = hexapod.state.body.y + hexapod.config.body[hexapod.legs[i]].x*Math.sin(_deg2rad(hexapod.state.body.AngZ)) + hexapod.config.body[hexapod.legs[i]].y*Math.cos(_deg2rad(hexapod.state.body.AngZ));
		}
	}

	function updateLeg() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			//console.log("updateLeg", hexapod.legs[i]);
			legAng(hexapod.legs[i]);
		}
	}
	
	function update() {
		updateBody();
		updateLeg();
	}
	
	function updateImageBody() {
		for (var i = 0; i < hexapod_image_objects.body_legs.length; i++) {
			hexapod_image_objects.body.points[i].x = hexapod.state.body[hexapod_image_objects.body_legs[i]].x;
			hexapod_image_objects.body.points[i].y = hexapod.state.body[hexapod_image_objects.body_legs[i]].y * -1;	// invert Y axis for display
		}
	}
	
	function updateImageAngDisplay(deg) {
		return (Math.round(deg*10)/10)+"&deg;";
	}
	function updateImageLeg(ID) {
		// calc X,Y,Z by angles
		var tmp = hexapod.const.leg[ID].AngCRad;
		hexapod_image_objects.leg[ID].C.x1.baseVal.value = hexapod.state.body[ID].x;
		hexapod_image_objects.leg[ID].C.y1.baseVal.value = hexapod.state.body[ID].y * -1;
		hexapod_image_objects.leg[ID].C.x2.baseVal.value = hexapod.config.leg[ID].Lc * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod.state.body[ID].x;
		hexapod_image_objects.leg[ID].C.y2.baseVal.value = (hexapod.config.leg[ID].Lc * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod.state.body[ID].y) * -1;
			hexapod_image_objects.dbg.leg[ID].C.x.baseVal[0].value = hexapod_image_objects.leg[ID].C.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].C.y.baseVal[0].value = hexapod_image_objects.leg[ID].C.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].C.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngC);

		hexapod_image_objects.leg[ID].F.x1.baseVal.value = hexapod_image_objects.leg[ID].C.x2.baseVal.value;
		hexapod_image_objects.leg[ID].F.y1.baseVal.value = hexapod_image_objects.leg[ID].C.y2.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.x.baseVal[0].value = hexapod_image_objects.leg[ID].F.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.y.baseVal[0].value = hexapod_image_objects.leg[ID].F.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngF);

		var tmpL = Math.sin(_deg2rad(90 - hexapod.state.leg[ID].AngF))*hexapod.config.leg[ID].Lf;
		hexapod_image_objects.leg[ID].F.x2.baseVal.value = tmpL * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod_image_objects.leg[ID].C.x2.baseVal.value;
		hexapod_image_objects.leg[ID].F.y2.baseVal.value = (tmpL * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) * -1 + hexapod_image_objects.leg[ID].C.y2.baseVal.value);
		

		hexapod_image_objects.leg[ID].T.x1.baseVal.value = hexapod_image_objects.leg[ID].F.x2.baseVal.value;
		hexapod_image_objects.leg[ID].T.y1.baseVal.value = hexapod_image_objects.leg[ID].F.y2.baseVal.value;		
			hexapod_image_objects.dbg.leg[ID].T.x.baseVal[0].value = hexapod_image_objects.leg[ID].T.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].T.y.baseVal[0].value = hexapod_image_objects.leg[ID].T.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].T.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngT);
		var tmpL = hexapod.state.leg[ID].L - tmpL - hexapod.config.leg[ID].Lc;
		hexapod_image_objects.leg[ID].T.x2.baseVal.value = tmpL * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod_image_objects.leg[ID].F.x2.baseVal.value;
		hexapod_image_objects.leg[ID].T.y2.baseVal.value = (tmpL * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) * -1 + hexapod_image_objects.leg[ID].F.y2.baseVal.value);
		
	}
	
	
	function updateImage() {
		updateImageBody();
		for (var i = 0; i < hexapod.legs.length; i++) {
			//console.log("updateImageLeg", hexapod.legs[i]);
			try {
				updateImageLeg(hexapod.legs[i]);
			} catch (e) {
				console.log("ERROR");
			}
		}
	}
	
	
	
	hexapod.dmove = {
			inProgress: false,
			distance_per_step: false,
			distance: false,
			dx: false,	// delta of full move
			dy: false,
			dAngZ: false,
			angle: false,
			steps: false,
			current_step: false,
			gait_steps: hexapod.config.gait.sequence.length,
			current_gait_step: 0,	// should not be reseted!!!
			step_deplay: 100	// pretent that this is servo move delay (ms) for one of the gait step (later this should be triggered by sensors on the end of the legs)
		};
		
	function moveTo (x,y) {
		hexapod.dmove.distance_per_step = 1;
		hexapod.dmove.dx = x - hexapod.state.body.x;
		hexapod.dmove.dy = y - hexapod.state.body.y;
		hexapod.dmove.distance = Math.sqrt(Math.pow(hexapod.dmove.dx,2) + Math.pow(hexapod.dmove.dy, 2));
		hexapod.dmove.AngZ = _rad2deg(Math.atan2(hexapod.dmove.dy, hexapod.dmove.dx));
		hexapod.dmove.dAngZ = hexapod.dmove.AngZ - hexapod.state.body.AngZ;
		hexapod.dmove.steps = Math.floor(hexapod.dmove.distance/hexapod.dmove.distance_per_step);
		
		// reset step counter
		hexapod.dmove.current_step = 0;

		hexapod.dmove.step_dx = hexapod.dmove.dx/hexapod.dmove.steps;
		hexapod.dmove.step_dy = hexapod.dmove.dy/hexapod.dmove.steps;
		hexapod.dmove.step_dAngZ = hexapod.dmove.dAngZ/hexapod.dmove.steps;
		moveToNext();
	}
	
	function moveToNext() {
		hexapod.dmove.inProgress = true;
		console.log("MOVE body", hexapod.dmove, hexapod.state.body);
		hexapod.state.body.x += hexapod.dmove.step_dx/hexapod.dmove.gait_steps;
		hexapod.state.body.y += hexapod.dmove.step_dy/hexapod.dmove.gait_steps;
		hexapod.state.body.AngZ += hexapod.dmove.step_dAngZ/hexapod.dmove.gait_steps;
		
		// TODO recalculate legs XYZ
		// TODO move
		
		updateBody();
		updateLeg();

		console.log("MOVE body", hexapod.dmove, hexapod.state.body);
		updateImage();
		
		hexapod.dmove.current_gait_step++;
		if (hexapod.dmove.current_gait_step >= hexapod.dmove.gait_steps) {
			hexapod.dmove.current_gait_step = 0;
			hexapod.dmove.current_step++;
			console.log("nextStep");
		}
		// TODO stop also on point archive, as it should be done faster then step
		if (hexapod.dmove.current_step >= hexapod.dmove.steps) {
			// TODO zero current position, e.g. x,y,z -> 0,0,0, the same for angles
			// TODO save moved XYZ and angles for odometry and later SLAM
			hexapod.dmove.inProgress = false;
		} else if (hexapod.dmove.inProgress) {
			setTimeout(moveToNext, hexapod.dmove.step_deplay);
		}
	}
	
	initHexa();

</script>
</body>
</html>
