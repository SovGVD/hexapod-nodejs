<html>
<head>
	<title>Hexapod</title>
		<style>
			line {
				stroke-width: 2px;
				stroke: black;
				stroke-linecap: round;
			}
			.on_the_ground {
				stroke-width: 10px;
			}
			#hexapod_body {
				fill: green;
				stroke: black;
				stroke-width: 1px;
			}

			#ghost_hexapod_body {
				fill: rgba(0, 255, 0, 0.1);
				stroke: rgba(0,0,0,0.5);
				stroke-width: 1px;
			}

			#hexapod_leg_LF_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LF_F { stroke: rgba(128,0,255,1); }
			#hexapod_leg_LF_T { stroke: rgba(255,0,0,1); }

			#hexapod_leg_LM_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LM_F { stroke: rgba(128,0,255,1); }
			#hexapod_leg_LM_T { stroke: rgba(255,0,0,1); }
			
			#hexapod_leg_LB_C { stroke: rgba(255,0,0,1); }
			#hexapod_leg_LB_F { stroke: rgba(128,0,255,0.7); }
			#hexapod_leg_LB_T { stroke: rgba(255,0,0,1); }
			

			#hexapod_leg_RF_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RF_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RF_T { stroke: rgba(0,255,0,1); }

			#hexapod_leg_RM_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RM_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RM_T { stroke: rgba(0,255,0,1); }
			
			#hexapod_leg_RB_C { stroke: rgba(0,255,0,1); }
			#hexapod_leg_RB_F { stroke: rgba(0,128,255,1); }
			#hexapod_leg_RB_T { stroke: rgba(0,255,0,1); }
			
			.svg_text_dbg {
				font: 20px sans-serif;
				fill: rgba(0,0,0,1);
				stroke: rgba(255,255,255,1);
				stroke-width: 0.1px;
			}
			
			.extected_leg_position {
				stroke-width: 1px;
				stroke: rgba(0,0,0,0.7);
			}
			.ghost_extected_leg_position {
				stroke-width: 1px;
				stroke: rgba(0,0,0,0.4);
			}
			
			.axis {
				stroke-width: 1px;
				stroke: rgba(0,0,0,0.5);
				stroke-dasharray: 20;
			}
	</style>
</head>
<body>
<svg width="600" height="600" id="svgimg">
	<g id="hexapod" transform="translate(300,300) scale(0.5)">
		<polygon points="0,0 1,1 2,2 3,3 4,4 5,5" id="hexapod_body" />
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_C" /><text x="0" y="0" id="hexapod_leg_LF_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_F" /><text x="0" y="0" id="hexapod_leg_LF_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_T" /><text x="0" y="0" id="hexapod_leg_LF_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_C" /><text x="0" y="0" id="hexapod_leg_LM_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_F" /><text x="0" y="0" id="hexapod_leg_LM_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_T" /><text x="0" y="0" id="hexapod_leg_LM_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_C" /><text x="0" y="0" id="hexapod_leg_LB_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_F" /><text x="0" y="0" id="hexapod_leg_LB_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_T" /><text x="0" y="0" id="hexapod_leg_LB_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_C" /><text x="0" y="0" id="hexapod_leg_RF_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_F" /><text x="0" y="0" id="hexapod_leg_RF_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_T" /><text x="0" y="0" id="hexapod_leg_RF_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_C" /><text x="0" y="0" id="hexapod_leg_RM_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_F" /><text x="0" y="0" id="hexapod_leg_RM_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_T" /><text x="0" y="0" id="hexapod_leg_RM_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_C" /><text x="0" y="0" id="hexapod_leg_RB_C_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_F" /><text x="0" y="0" id="hexapod_leg_RB_F_DBG" class="svg_text_dbg"></text>
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_T" /><text x="0" y="0" id="hexapod_leg_RB_T_DBG" class="svg_text_dbg"></text>
		
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LF_expected" class="extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LM_expected" class="extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_LB_expected" class="extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RF_expected" class="extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RM_expected" class="extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="hexapod_leg_RB_expected" class="extected_leg_position" />
		
		<polygon points="0,0 1,1 2,2 3,3 4,4 5,5" id="ghost_hexapod_body" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_LF_expected" class="ghost_extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_LM_expected" class="ghost_extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_LB_expected" class="ghost_extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_RF_expected" class="ghost_extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_RM_expected" class="ghost_extected_leg_position" />
		<line x1="0" y1="0" x2="0" y2="0" id="ghost_hexapod_leg_RB_expected" class="ghost_extected_leg_position" />
		
		<line x1="0" y1="-10000" x2="0" y2="10000" class="axis" />
		<line x1="-10000" y1="0" x2="10000" y2="0" class="axis" />
	</g>
</svg>
<script>
	function G(id) {
		return document.getElementById(id);
	}
	var hexapod_image_objects = {
		svgimg: G('svgimg'),
		body_legs: ["LF", "RF", "RM", "RB", "LB", "LM"],
		body: G('hexapod_body'),
		ghost_body: G('ghost_hexapod_body'),
		leg: {
			LF: {
				C: G('hexapod_leg_LF_C'),
				F: G('hexapod_leg_LF_F'),
				T: G('hexapod_leg_LF_T'),
			},
			LM: {
				C: G('hexapod_leg_LM_C'),
				F: G('hexapod_leg_LM_F'),
				T: G('hexapod_leg_LM_T'),
			},
			LB: {
				C: G('hexapod_leg_LB_C'),
				F: G('hexapod_leg_LB_F'),
				T: G('hexapod_leg_LB_T'),
			},
			RF: {
				C: G('hexapod_leg_RF_C'),
				F: G('hexapod_leg_RF_F'),
				T: G('hexapod_leg_RF_T'),
			},
			RM: {
				C: G('hexapod_leg_RM_C'),
				F: G('hexapod_leg_RM_F'),
				T: G('hexapod_leg_RM_T'),
			},
			RB: {
				C: G('hexapod_leg_RB_C'),
				F: G('hexapod_leg_RB_F'),
				T: G('hexapod_leg_RB_T'),
			},
		},
		dbg: {
			leg: {
				LF: {
					C: G('hexapod_leg_LF_C_DBG'),
					F: G('hexapod_leg_LF_F_DBG'),
					T: G('hexapod_leg_LF_T_DBG'),
					expected: G('hexapod_leg_LF_expected'),
					ghost: G('ghost_hexapod_leg_LF_expected'),
				},
				LM: {
					C: G('hexapod_leg_LM_C_DBG'),
					F: G('hexapod_leg_LM_F_DBG'),
					T: G('hexapod_leg_LM_T_DBG'),
					expected: G('hexapod_leg_LM_expected'),
					ghost: G('ghost_hexapod_leg_LM_expected'),
				},
				LB: {
					C: G('hexapod_leg_LB_C_DBG'),
					F: G('hexapod_leg_LB_F_DBG'),
					T: G('hexapod_leg_LB_T_DBG'),
					expected: G('hexapod_leg_LB_expected'),
					ghost: G('ghost_hexapod_leg_LB_expected'),
				},
				RF: {
					C: G('hexapod_leg_RF_C_DBG'),
					F: G('hexapod_leg_RF_F_DBG'),
					T: G('hexapod_leg_RF_T_DBG'),
					expected: G('hexapod_leg_RF_expected'),
					ghost: G('ghost_hexapod_leg_RF_expected'),
				},
				RM: {
					C: G('hexapod_leg_RM_C_DBG'),
					F: G('hexapod_leg_RM_F_DBG'),
					T: G('hexapod_leg_RM_T_DBG'),
					expected: G('hexapod_leg_RM_expected'),
					ghost: G('ghost_hexapod_leg_RM_expected'),
				},
				RB: {
					C: G('hexapod_leg_RB_C_DBG'),
					F: G('hexapod_leg_RB_F_DBG'),
					T: G('hexapod_leg_RB_T_DBG'),
					expected: G('hexapod_leg_RB_expected'),
					ghost: G('ghost_hexapod_leg_RB_expected'),
				},
			}
		}
	};
	// hexapod sizes
	var hexapod = {};
	hexapod.legs = ["LF", "LM", "LB", "RF", "RM", "RB"];
	hexapod.config = {
			body: {
				x: 0, y: 0, z: 0,
				AngX: 0, AngY: 0, AngZ: 0,
				LF:  { x:  75, y:  40, z: -80 },	// z is the distance from body center
				LM:  { x:   0, y:  65, z: -80 },	// so it is e.g. -50 if we need to be on 50 above ground
				LB:  { x: -75, y:  40, z: -80 },	// ground is mostly for the hexagon plane of legs
				RF:  { x:  75, y: -40, z: -80 },	// TODO getGround
				RM:  { x:   0, y: -65, z: -80 },
				RB:  { x: -75, y: -40, z: -80 }
			},
			leg: {
				LF: { AngC: { min: -50, max: 50, default: 25 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } },	// TODO min and max!!! AngF (0...90)
				LM: { AngC: { min: -50, max: 50, default: 0 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } },
				LB: { AngC: { min: -50, max: 50, default: -25 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } },
				RF: { AngC: { min: -50, max: 50, default: -25 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } },
				RM: { AngC: { min: -50, max: 50, default: 0 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } },
				RB: { AngC: { min: -50, max: 50, default: 25 }, Lc: 27, Lf: 85, Lt: 120, L: { min: 40, max: 250, default: 80 } }
			},
			gait: {
				type: "RIPPLE",	// balance between stable (4 legs on the ground) and speed (not so slow as wave 1 by 1, bu not so fast as with tripod)
				gaitZ: 20,	// This is only for 2D model, in real life Z should be calculate by creating 3D surface around robot (sounds cool).
				sequence: [
					{ "LF":  0, "LM":  0, "LB":  2, "RF":  0, "RM": -1, "RB":  0 },	// 0  - on the ground (stance), 
					{ "LF":  0, "LM":  0, "LB": -1, "RF":  2, "RM":  0, "RB":  0 }, // >0 - in the air (swing) number of steps before ground,
					{ "LF":  0, "LM":  2, "LB":  0, "RF": -1, "RM":  0, "RB":  0 }, // -1 - on the way to the ground (any step after), probably just ignore
					{ "LF":  0, "LM": -1, "LB":  0, "RF":  0, "RM":  0, "RB":  2 },
					{ "LF":  2, "LM":  0, "LB":  0, "RF":  0, "RM":  0, "RB": -1 },
					{ "LF": -1, "LM":  0, "LB":  0, "RF":  0, "RM":  2, "RB":  0 },
					{ "LF":  0, "LM":  0, "LB":  2, "RF":  0, "RM": -1, "RB":  0 },
					{ "LF":  0, "LM":  0, "LB": -1, "RF":  2, "RM":  0, "RB":  0 },
					{ "LF":  0, "LM":  2, "LB":  0, "RF": -1, "RM":  0, "RB":  0 },
					{ "LF":  0, "LM": -1, "LB":  0, "RF":  0, "RM":  0, "RB":  2 },
					{ "LF":  2, "LM":  0, "LB":  0, "RF":  0, "RM":  0, "RB": -1 },
					{ "LF": -1, "LM":  0, "LB":  0, "RF":  0, "RM":  2, "RB":  0 }
				]
			}
		};
	hexapod.const = {
		leg: {
			LF: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false },
			LM: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false },
			LB: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false },
			RF: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false },
			RM: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false },
			RB: { Lf2: false, Lt2: false, LtLf: false, AngToBody: false }
		}
	},
	hexapod.preState = false;
	hexapod.state = {
			body: {
				x: 0, y: 0, z: 0, 
				AngX: 0, AngY: 0, AngZ: 0,
				LF:  { x: false, y: false, z: false },
				LM:  { x: false, y: false, z: false },
				LB:  { x: false, y: false, z: false },
				RF:  { x: false, y: false, z: false },
				RM:  { x: false, y: false, z: false },
				RB:  { x: false, y: false, z: false },
			},
			leg: {
				LF: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				LM: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				LB: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RF: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RM: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false },
				RB: { AngC: false, AngF: false, AngT: false, x: false, y:false, z: false, L: false }
			}
		};
	function legAng (ID) {
		// TODO, precheck leg limits:
		// 1. create 3D polygon of max/min available positions, including angles limits
		// 2. check if x1,y1,z1 in that polygon
		hexapod.state.leg[ID].L = Math.sqrt(Math.pow(hexapod.state.leg[ID].x - hexapod.state.body[ID].x, 2) + Math.pow(hexapod.state.leg[ID].y - hexapod.state.body[ID].y, 2));

		/*
		                      
		AngleCoxa = atan2 ( (y1-y0), (x1-x0) )
								
		*/
		hexapod.state.leg[ID].AngC = _rad2deg(Math.atan2((hexapod.state.leg[ID].y - hexapod.state.body[ID].y), (hexapod.state.leg[ID].x - hexapod.state.body[ID].x)) - hexapod.const.leg[ID].AngCRad);	// -90...90
		hexapod.state.leg[ID].AngC -= hexapod.state.body.AngZ;
		hexapod.state.leg[ID].AngC = _degNorm(hexapod.state.leg[ID].AngC);
		if (hexapod.state.leg[ID].AngC > 180) hexapod.state.leg[ID].AngC -= 360;
		/*
								   Lf^2 + (D^2 + (L - Lc)^2) - Lt^2       PI             L - Lc
			AngleFemur = arccos ( ---------------------------------- ) - ---- + arctan( -------- )
								   2 * Lf * sqrt(D^2 + (L - Lc)^2)         2               D

										Lf^2 + (D^2 + (L - Lc)^2) - Lt^2                           D
			AngleFemur = PI - arccos ( ---------------------------------- ) - arccos ( ------------------------ )
										2 * Lf * sqrt(D^2 + (L - Lc)^2)                 sqrt(D^2 + (L - Lc)^2)

		*/
		var tmp = Math.pow(hexapod.state.body.z - hexapod.state.leg[ID].z, 2) + Math.pow( hexapod.state.leg[ID].L - hexapod.config.leg[ID].Lc, 2);
		hexapod.state.leg[ID].AngF = _rad2deg(Math.PI - Math.acos( (hexapod.const.leg[ID].Lf2 + tmp - hexapod.const.leg[ID].Lt2) / (2 * hexapod.config.leg[ID].Lf * Math.sqrt(tmp)) ) - Math.acos((hexapod.state.body.z - hexapod.state.leg[ID].z)/Math.sqrt(tmp)));

		/*
							   Lt^2 + Lf^2 - (D^2 + (L - Lc)^2)
		AngleTibia = arccos ( --------------------------------- )
										 2 * Lt * Lf
		*/
		hexapod.state.leg[ID].AngT = _rad2deg(Math.acos((hexapod.const.leg[ID].Lt2 + hexapod.const.leg[ID].Lf2 - tmp) / (2 * hexapod.const.leg[ID].LtLf)));
	}
	
	function _degNorm(deg) {
		while (deg > 360 || deg < 0) {
			if (deg < 0) deg += 360;
			if (deg > 360) deg -= 360;
		}
		return deg;
	}
	function _deg2rad(deg) {
		return Math.PI/180*deg;
	}

	function _rad2deg(rad) {
		return _degNorm(180/Math.PI*rad);
	}
	
	function initBody() {
		hexapod.state.body.x    = parseFloat(hexapod.config.body.x);
		hexapod.state.body.y    = parseFloat(hexapod.config.body.y);
		hexapod.state.body.z    = parseFloat(hexapod.config.body.z);
		hexapod.state.body.AngX = parseFloat(hexapod.config.body.AngX);
		hexapod.state.body.AngY = parseFloat(hexapod.config.body.AngY);
		hexapod.state.body.AngZ = parseFloat(hexapod.config.body.AngZ);

		var tmp = getDefaultBodyState( {
				x: parseFloat(hexapod.state.body.x),
				y: parseFloat(hexapod.state.body.y),
				z: parseFloat(hexapod.state.body.z),
				AngX: parseFloat(hexapod.state.body.AngX),
				AngY: parseFloat(hexapod.state.body.AngY),
				AngZ: parseFloat(hexapod.state.body.AngZ)
			}, false );
		for (var i = 0; i < hexapod.legs.length; i++) {
			var ID = hexapod.legs[i];
			hexapod.state.body[ID].x = parseFloat(tmp.body[ID].x);
			hexapod.state.body[ID].y = parseFloat(tmp.body[ID].y);
			hexapod.state.body[ID].z = parseFloat(tmp.body[ID].z);
			hexapod.state.leg[ID].x  = parseFloat(tmp.leg[ID].x);
			hexapod.state.leg[ID].y  = parseFloat(tmp.leg[ID].y);
			hexapod.state.leg[ID].z  = parseFloat(tmp.leg[ID].z);
		}
	}
	
	
	function getGround(x,y) {	// TODO this will be used for 3D surface only
		return -100;
	}
	
	function isLegOnTheGround(ID) {
		if (hexapod.state.leg[ID].z == getGround(hexapod.state.leg[ID].x,hexapod.state.leg[ID].y)) {
			return true;
		}
		return false;
	}
	
	
	function getDefaultBodyState(body, _ID) {
		//var _ID = false;	// DEBUG
		// this function should return default hexapod state at body.x, body.y, body.z point, rotated body.AngX (TODO and don't forgot about balance), body.AngY(TODO...), boby.AngZ
		var ret = {
				body: {
				},
				leg: {
				}
			};
		var _tmp_cos = Math.cos(_deg2rad(body.AngZ));
		var _tmp_sin = Math.sin(_deg2rad(body.AngZ));

		for (var i = 0; i < hexapod.legs.length; i++) {
			if (_ID === false || _ID == hexapod.legs[i] ) {
				var ID = hexapod.legs[i];
				ret.body[ID] = { };
				ret.leg[ID] = { };

				ret.body[ID].x = body.x + (hexapod.config.body[ID].x)*_tmp_cos - (hexapod.config.body[ID].y)*_tmp_sin;
				ret.body[ID].y = body.y + (hexapod.config.body[ID].x)*_tmp_sin + (hexapod.config.body[ID].y)*_tmp_cos;
				ret.body[ID].z = parseFloat(body.z);
				
				ret.leg[ID].x = body.x + (hexapod.const.leg[ID].defaultX)*_tmp_cos - (hexapod.const.leg[ID].defaultY)*_tmp_sin;
				ret.leg[ID].y = body.y + (hexapod.const.leg[ID].defaultX)*_tmp_sin + (hexapod.const.leg[ID].defaultY)*_tmp_cos;
				ret.leg[ID].z = parseFloat(getGround(ret.leg[ID].x, ret.leg[ID].y));
				
				hexapod_image_objects.dbg.leg[ID].ghost.x1.baseVal.value = ret.body[ID].x;
				hexapod_image_objects.dbg.leg[ID].ghost.y1.baseVal.value = ret.body[ID].y * -1;
				hexapod_image_objects.dbg.leg[ID].ghost.x2.baseVal.value = ret.leg[ID].x;
				hexapod_image_objects.dbg.leg[ID].ghost.y2.baseVal.value = ret.leg[ID].y * -1;
			}
		}
		
		for (var i = 0; i < hexapod_image_objects.body_legs.length; i++) {
			if (_ID === false || _ID == hexapod_image_objects.body_legs[i] ) {
				hexapod_image_objects.ghost_body.points[i].x = ret.body[hexapod_image_objects.body_legs[i]].x;
				hexapod_image_objects.ghost_body.points[i].y = ret.body[hexapod_image_objects.body_legs[i]].y * -1;	// invert Y axis for display
			}
		}
		
		return ret;
	}
		
	function initState() {
		initBody();
	}
	
	function initConst() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			var ID = hexapod.legs[i];
			hexapod.const.leg[ID].Lf2 = Math.pow(hexapod.config.leg[ID].Lf, 2);
			hexapod.const.leg[ID].Lt2 = Math.pow(hexapod.config.leg[ID].Lt, 2);
			hexapod.const.leg[ID].LtLf = hexapod.config.leg[ID].Lt * hexapod.config.leg[ID].Lf;
			hexapod.const.leg[ID].AngCRad = Math.atan2((hexapod.config.body[ID].y - hexapod.config.body.y), (hexapod.config.body[ID].x - hexapod.config.body.x));
			hexapod.const.leg[ID].defaultX = Math.cos(_deg2rad(hexapod.config.leg[ID].AngC.default+_rad2deg(hexapod.const.leg[ID].AngCRad))) * hexapod.config.leg[ID].L.default + hexapod.config.body[ID].x;
			hexapod.const.leg[ID].defaultY = Math.sin(_deg2rad(hexapod.config.leg[ID].AngC.default+_rad2deg(hexapod.const.leg[ID].AngCRad))) * hexapod.config.leg[ID].L.default + hexapod.config.body[ID].y;
		}
		// TODO init min/max 3d polygon for legs
	}
	
	function initHexa() {
		initConst();
		initState();
		update();
		updateImage();
		
		setInterval(move, 1);
	}
	
	function preCalc(vector, ID) {
		// this function should return hexapod expected state
		// for more advanced solution that can be changed to anything else to predict/choose new state of the hexapod
		var _tmp = _degNorm(hexapod.state.body.AngZ + vector.AngZ);
		var _tmp_sin = Math.sin(_deg2rad(_tmp));
		var _tmp_cos = Math.cos(_deg2rad(_tmp));
		var futurePosition = getDefaultBodyState( {
				x: hexapod.state.body.x + vector.x*_tmp_cos - vector.y*_tmp_sin,
				y: hexapod.state.body.y + vector.x*_tmp_sin + vector.y*_tmp_cos,
				z: hexapod.state.body.z,
				AngX: hexapod.state.body.AngX,
				AngY: hexapod.state.body.AngY,
				AngZ: _tmp
			}, ID );
		return futurePosition;
	}
	
	function updateBody() {
		// init body position and angle
		for (var i = 0; i < hexapod.legs.length; i++) {
			hexapod.state.body[hexapod.legs[i]].x = hexapod.state.body.x + hexapod.config.body[hexapod.legs[i]].x*Math.cos(_deg2rad(hexapod.state.body.AngZ)) - hexapod.config.body[hexapod.legs[i]].y*Math.sin(_deg2rad(hexapod.state.body.AngZ));
			hexapod.state.body[hexapod.legs[i]].y = hexapod.state.body.y + hexapod.config.body[hexapod.legs[i]].x*Math.sin(_deg2rad(hexapod.state.body.AngZ)) + hexapod.config.body[hexapod.legs[i]].y*Math.cos(_deg2rad(hexapod.state.body.AngZ));
		}
	}

	function updateLeg() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			//console.log("updateLeg", hexapod.legs[i]);
			legAng(hexapod.legs[i]);
		}
	}
	
	function update() {
		updateBody();
		updateLeg();
	}
	
	function updateImageBody() {
		for (var i = 0; i < hexapod_image_objects.body_legs.length; i++) {
			hexapod_image_objects.body.points[i].x = hexapod.state.body[hexapod_image_objects.body_legs[i]].x;
			hexapod_image_objects.body.points[i].y = hexapod.state.body[hexapod_image_objects.body_legs[i]].y * -1;	// invert Y axis for display
		}
	}
	
	function updateImageAngDisplay(deg) {
		return (Math.round(deg*10)/10)+"&deg;";
	}
	function updateImageLeg(ID) {
		hexapod_image_objects.dbg.leg[ID].expected.x1.baseVal.value = hexapod.state.body[ID].x;
		hexapod_image_objects.dbg.leg[ID].expected.y1.baseVal.value = hexapod.state.body[ID].y * -1;
		hexapod_image_objects.dbg.leg[ID].expected.x2.baseVal.value = hexapod.state.leg[ID].x;
		hexapod_image_objects.dbg.leg[ID].expected.y2.baseVal.value = hexapod.state.leg[ID].y * -1;

		// calc X,Y,Z by angles
		var tmp = hexapod.const.leg[ID].AngCRad + _deg2rad(hexapod.state.body.AngZ);
		hexapod_image_objects.leg[ID].C.x1.baseVal.value = hexapod.state.body[ID].x;
		hexapod_image_objects.leg[ID].C.y1.baseVal.value = hexapod.state.body[ID].y * -1;
		hexapod_image_objects.leg[ID].C.x2.baseVal.value = hexapod.config.leg[ID].Lc * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod.state.body[ID].x;
		hexapod_image_objects.leg[ID].C.y2.baseVal.value = (hexapod.config.leg[ID].Lc * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod.state.body[ID].y) * -1;
			hexapod_image_objects.dbg.leg[ID].C.x.baseVal[0].value = hexapod_image_objects.leg[ID].C.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].C.y.baseVal[0].value = hexapod_image_objects.leg[ID].C.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].C.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngC);

		hexapod_image_objects.leg[ID].F.x1.baseVal.value = hexapod_image_objects.leg[ID].C.x2.baseVal.value;
		hexapod_image_objects.leg[ID].F.y1.baseVal.value = hexapod_image_objects.leg[ID].C.y2.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.x.baseVal[0].value = hexapod_image_objects.leg[ID].F.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.y.baseVal[0].value = hexapod_image_objects.leg[ID].F.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].F.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngF);

		var tmpL = Math.sin(_deg2rad(hexapod.state.leg[ID].AngF))*hexapod.config.leg[ID].Lf;
		hexapod_image_objects.leg[ID].F.x2.baseVal.value = tmpL * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod_image_objects.leg[ID].C.x2.baseVal.value;
		hexapod_image_objects.leg[ID].F.y2.baseVal.value = (tmpL * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) * -1 + hexapod_image_objects.leg[ID].C.y2.baseVal.value);
		

		hexapod_image_objects.leg[ID].T.x1.baseVal.value = hexapod_image_objects.leg[ID].F.x2.baseVal.value;
		hexapod_image_objects.leg[ID].T.y1.baseVal.value = hexapod_image_objects.leg[ID].F.y2.baseVal.value;		
			hexapod_image_objects.dbg.leg[ID].T.x.baseVal[0].value = hexapod_image_objects.leg[ID].T.x1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].T.y.baseVal[0].value = hexapod_image_objects.leg[ID].T.y1.baseVal.value;
			hexapod_image_objects.dbg.leg[ID].T.innerHTML = updateImageAngDisplay(hexapod.state.leg[ID].AngT) + " z:" + (Math.round(hexapod.state.leg[ID].z*10)/10);
		var tmpL = hexapod.state.leg[ID].L - tmpL - hexapod.config.leg[ID].Lc;
		hexapod_image_objects.leg[ID].T.x2.baseVal.value = tmpL * Math.cos(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) + hexapod_image_objects.leg[ID].F.x2.baseVal.value;
		hexapod_image_objects.leg[ID].T.y2.baseVal.value = (tmpL * Math.sin(_deg2rad(hexapod.state.leg[ID].AngC)+tmp) * -1 + hexapod_image_objects.leg[ID].F.y2.baseVal.value);
		if (isLegOnTheGround(ID)) {
			hexapod_image_objects.leg[ID].T.className.baseVal = 'on_the_ground';
		} else {
			hexapod_image_objects.leg[ID].T.className.baseVal = '';
		}
		
	}
	
	
	function updateImage() {
		updateImageBody();
		for (var i = 0; i < hexapod.legs.length; i++) {
			//console.log("updateImageLeg", hexapod.legs[i]);
			try {
				updateImageLeg(hexapod.legs[i]);
			} catch (e) {
				console.log("ERROR");
			}
		}
	}
	
	
	
	//hexapod.smooth = 10;
	hexapod.dmove = {
			speed: 100,
			angspeed: 5,
			inProgress: false,
			distance_per_step: false,
			distance: false,
			dx: false,	// delta of full move
			dy: false,
			dAngZ: false,
			angle: false,
			
			gait_z: hexapod.config.gait.gaitZ,
			
			gaitsteps: parseInt(hexapod.config.gait.sequence.length),
			current_gaitstep: 0,
			
			smooth: 10,	// event per gaitstep (smooth)
			current_smooth: 0,
			
			step_delay: 20,	// loop delay???
			leg: {
				LF: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false },
				LM: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false },
				LB: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false },
				RF: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false },
				RM: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false },
				RB: { inProgress: false, gaitstep_dx: false, gaitstep_dy: false, gaitstep_dz: false, gait_z: 0, ground_z: false, current_subgaitstep: false, subgaitsteps: false }
			}
		};
	hexapod.dmove.totalsteps = hexapod.dmove.gaitsteps*hexapod.dmove.smooth;
	console.log(hexapod.dmove);
	
	
	function move() {
		hexapod.dmove.dAngZ = parseFloat(moveData.AngZ)*hexapod.dmove.angspeed;

		hexapod.dmove.dx = parseFloat(moveData.x)*hexapod.dmove.speed;
		hexapod.dmove.dy = parseFloat(moveData.y)*hexapod.dmove.speed;
		if (hexapod.dmove.dx !=0 || hexapod.dmove.dy !=0 || hexapod.dmove.dAngZ !=0) {
			hexapod.dmove.inProgress = true;
		} else {
			hexapod.dmove.inProgress = false;
		}
	}
	
	
	function movetoNextGaitUpdateLeg(ID) {
		if (hexapod.dmove.leg[ID].inProgress) {
			var g_move_progress = hexapod.dmove.leg[ID].current_subgaitstep / hexapod.dmove.leg[ID].subgaitsteps;
			hexapod.state.leg[ID].x += hexapod.dmove.leg[ID].dx;	// probably it is a good idea to use smooth function for all axis, not only x^4 for Z axis
			hexapod.state.leg[ID].y += hexapod.dmove.leg[ID].dy;
			// Z axis on flat surface will use y=-(2*x-1)^4+1
			// this will get us `x` [0...1] where `y` will be `0` to `1` to `0`, looks like perfect (and simple!) for leg 
			// as in the middle it will be max and zeros at the begin and end
			hexapod.state.leg[ID].z = (-Math.pow(2*g_move_progress-1,4)+1) * hexapod.dmove.leg[ID].gait_z + hexapod.dmove.leg[ID].ground_z;
		}
	}
	
	function moveToNextGait() {
		for (var i = 0; i < hexapod.legs.length; i++) {
			var ID = hexapod.legs[i];
			//console.log("DBG1", hexapod.dmove.current_gaitstep, hexapod.dmove.gaitsteps, ID);
			var leg_steps = hexapod.config.gait.sequence[parseInt(hexapod.dmove.current_gaitstep)][ID];
			
			//console.log("DBG", hexapod.dmove.current_gaitstep, hexapod.dmove.current_smooth, ID, leg_steps, hexapod.dmove.leg);
			if (hexapod.dmove.leg[ID].inProgress) {
				if (hexapod.dmove.leg[ID].current_subgaitstep < hexapod.dmove.leg[ID].subgaitsteps) {
					// continue gait
					hexapod.dmove.leg[ID].current_subgaitstep++;
					movetoNextGaitUpdateLeg(ID);
				} else {
					// gait finished
					console.log("Gait finished", hexapod.dmove.current_gaitstep, hexapod.dmove.current_smooth, ID,hexapod.dmove.leg[ID]);
					hexapod.dmove.leg[ID].subgaitsteps = false;
					hexapod.dmove.leg[ID].current_subgaitstep = false;
					hexapod.dmove.leg[ID].inProgress = false;	// looks like the same
				}
			}

			if (leg_steps > 0) {
				if (!hexapod.dmove.leg[ID].inProgress) {
					console.log("Begin gait", hexapod.dmove.current_gaitstep, hexapod.dmove.current_smooth, ID);
					// begin gait
					hexapod.dmove.leg[ID].inProgress = true;
					hexapod.dmove.leg[ID].current_subgaitstep = 0;
					hexapod.dmove.leg[ID].gait_z = hexapod.dmove.gait_z;
					hexapod.dmove.leg[ID].ground_z = -100; 	// TODO, not just 80, but expected ground level
					hexapod.dmove.leg[ID].subgaitsteps = parseInt(hexapod.dmove.smooth)*leg_steps;
					var tmp = preCalc({
							x: hexapod.dmove.dx/3,
							y: hexapod.dmove.dy/3,
							z: 0,
							AngZ: hexapod.dmove.dAngZ
						}, ID);

					hexapod.dmove.leg[ID].dx = (tmp.leg[ID].x - hexapod.state.leg[ID].x) / hexapod.dmove.leg[ID].subgaitsteps;
					hexapod.dmove.leg[ID].dy = (tmp.leg[ID].y - hexapod.state.leg[ID].y) / hexapod.dmove.leg[ID].subgaitsteps;
				}				
			}
		}
		hexapod.dmove.current_smooth++;
		if (hexapod.dmove.current_smooth >= hexapod.dmove.smooth) {
			hexapod.dmove.current_smooth = 0;
			hexapod.dmove.current_gaitstep++;
			if (hexapod.dmove.current_gaitstep >= hexapod.dmove.gaitsteps) {
				hexapod.dmove.current_gaitstep = 0;
			}
		}
	}
	
	// LOOP
	setInterval(moveToNext,hexapod.dmove.step_delay);
	
	function moveToNext() {
		if (hexapod.dmove.inProgress) {
			//console.log("move");
			hexapod.state.body.AngZ += hexapod.dmove.dAngZ/hexapod.dmove.gaitsteps;
			hexapod.state.body.AngZ = _degNorm(hexapod.state.body.AngZ);

			hexapod.state.body.x += (hexapod.dmove.dx/hexapod.dmove.totalsteps)*Math.cos(_deg2rad(hexapod.state.body.AngZ)) - (hexapod.dmove.dy/hexapod.dmove.totalsteps)*Math.sin(_deg2rad(hexapod.state.body.AngZ));
			hexapod.state.body.y += (hexapod.dmove.dx/hexapod.dmove.totalsteps)*Math.sin(_deg2rad(hexapod.state.body.AngZ)) + (hexapod.dmove.dy/hexapod.dmove.totalsteps)*Math.cos(_deg2rad(hexapod.state.body.AngZ));
			
			moveToNextGait();
			updateBody();
			updateLeg();
			

			//console.log("MOVE body", hexapod.state.body);
			updateImage();
			//if (hexapod.state.leg != false) {
				sendCmd('state', [
					-hexapod.state.leg.LF.AngC+90, 180-hexapod.state.leg.LF.AngF, hexapod.state.leg.LF.AngT, 
					-hexapod.state.leg.LM.AngC+90, 180-hexapod.state.leg.LM.AngF, hexapod.state.leg.LM.AngT, 
					-hexapod.state.leg.LB.AngC+90, 180-hexapod.state.leg.LB.AngF, hexapod.state.leg.LB.AngT, 
					90,90,90,
					hexapod.state.leg.RF.AngC+90, 180-hexapod.state.leg.RF.AngF, hexapod.state.leg.RF.AngT, 
					hexapod.state.leg.RM.AngC+90, 180-hexapod.state.leg.RM.AngF, hexapod.state.leg.RM.AngT, 
					hexapod.state.leg.RB.AngC+90, 180-hexapod.state.leg.RB.AngF, hexapod.state.leg.RB.AngT,
					90,90,90
				]);
			//}
			//sendCmd('state', {leg:{ RM: { AngC:  } }});
		} else {
			//console.log("ping");
		}
	}
	
	
	// moveData with vector x,y,z + AngZ (yaw)
	var moveData = {
		x : 0,
		y : 0,
		z : 0,
		AngZ : 0
	};
	
	
	// Keyboard
	var kMap = { };
	function initKeyboard() {
		document.body.onkeydown = document.body.onkeyup = function (e) { 
			e.preventDefault();
			kMap[e.code] = (e.type=='keydown'?true:false); 
			keyboardEvent(e);
		};
	}
	function keyboardEvent(e) {
		if (kMap.KeyW === true || kMap.KeyA === true || kMap.KeyS === true || kMap.KeyD === true ||
			kMap.ArrowUp === true || kMap.ArrowDown === true || kMap.ArrowLeft === true || kMap.ArrowRight === true) {
			
			moveData.AngZ = -0.5*(kMap.KeyA === true?-1:(kMap.KeyD === true?1:0));
			//stickData.throttle = speed*(kMap.KeyS === true?-1:(kMap.KeyW === true?1:0));
			moveData.y = -(kMap.ArrowLeft === true?-1:(kMap.ArrowRight === true?1:0));
			moveData.x = (kMap.ArrowDown === true?-1:(kMap.ArrowUp === true?1:0));			
		} else {
			moveData = {
				x : 0,
				y : 0,
				z : 0,
				AngZ : 0
			};
		}
		return false;
	}
	// Gamepad
	var gp = false;	// GamePad object
	var gpInterval = false;
	function initGamepad() {
		window.addEventListener("gamepadconnected", gamepadConnectHandler);
		window.addEventListener("gamepaddisconnected", gamepadDisconnectHandler);
	}
	function gamepadConnectHandler (e) {
		gamepadAdd(e.gamepad);
	}
	function gamepadDisconnectHandler (e) {
		gamepadRemove(e.gamepad);
		moveData = {
			x : 0,
			y : 0,
			z : 0,
			AngZ : 0
		};
	}
	function gamepadRemove(g) {
		gp = false;
	}
	function gamepadAdd(g) {
		initGamePadEvents();
		gp = g;
	}
	function initGamePadEvents() {
		if (gpInterval) {
			clearInterval(gpInterval);
			initGamePadEvents();
		} else {
			setInterval(function () { gamepadData() }.bind(this), 100);
		}
	}
	function gamepadData() {
		gp = navigator.getGamepads()[0];
		moveData.AngZ = -gp.axes[0]*0.5;	// less speed of rotation TODO
		moveData.z = -gp.axes[1];
		moveData.y = -gp.axes[2];
		moveData.x = -gp.axes[3];
		//console.log("Vector", moveData);
	}
	initGamepad();
	initKeyboard();
	
	initHexa();
	
	
	
	// Send angles to real robot
	var ws_control = false;
	var host="127.0.0.1";
	function initControlFeedReceive() {
		ws_control.send("t");
	}
	function processControl(data) {
		//console.log(data);
	}
	function sendCmd(_cmd, _value) {
		if (ws_control) {
			ws_control.send(JSON.stringify({ cmd: { cmd: _cmd, value: _value } }));
		}
	}
	function initControl() {
		try {
			ws_control = new WebSocket("ws://"+host+":8082/");
			ws_control.onmessage = function (data) {
				processControl(data);
			};
			ws_control.onopen = function () {
				initControlFeedReceive();
			};
			ws_control.onerror = function () {
				ws_control.close();
			}
		} catch (e) {
			console.log("Error","Control", "reconnect");
		}
	}
	initControl();

</script>
</body>
</html>
